#Import reuired libraries
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity

#Function to compare descriptions
def recommend_by_description(descriptions, isbns, books_read, recommendation_number):
    #Returns the first few books if there is nothing to recommend with
    if len(books_read) == 0:
        return isbns[:recommendation_number+1]
    else:
        #Turns books into vectors taking sets of 2 words and calculating tfidf
        vectorizer = TfidfVectorizer(lowercase=True, stop_words='english', ngram_range=(2, 2), min_df = 1)
        #Creates a matrix for the vectors
        tfidf_matrix = vectorizer.fit_transform(descriptions)
        read_indices = []
        #Takes books that have been read and obtains vectors from the matrix
        for book in books_read:
            read_indices.append(isbns.index(book))
        required_rows = [tfidf_matrix[i] for i in read_indices]
        #The function below sums the relevant vectors to create a user vector
        if len(required_rows) > 0:
            cumulation = required_rows[0]
            for i in range(len(required_rows)-1):
                cumulation = cumulation+required_rows[i+1]
        else:
            cumulation = []
        #This runs calculates the cosine value between each vector
        sg = cosine_similarity(cumulation, tfidf_matrix)
        #The results are enumerated so they can be sorted and output in order
        sig = list(enumerate(sg[0]))
        sig = sorted(sig, key=lambda x: x[1], reverse=True)
        #Eliminates books that have been read as they will be the closest match
        sig = sig[0:(recommendation_number)+len(books_read)]
        final = []
        for i in range(len(sig)):
            isbn = isbns[sig[i][0]]
            if isbn not in books_read:
                final.append(isbn)
        #Returns the number of ISBNs depending on the input number
        return(final[:recommendation_number+1])


#Same as above function but for genres
def recommend_by_genre(genres, isbns, books_read, recommendation_number):
    if len(books_read) == 0:
        return isbns[:recommendation_number+1]
    #The process is the same but the vectors are generated by count not tfidf
    else:
        vectorizer = CountVectorizer(ngram_range=(1, 3))
        matrix = vectorizer.fit_transform(genres)
        read_indices = []
        for book in books_read:
            read_indices.append(isbns.index(book))
        required_rows = [matrix[i] for i in read_indices]

        if len(required_rows) > 0:
            cumulation = required_rows[0]
            for i in range(len(required_rows)-1):
                cumulation = cumulation+required_rows[i+1]
        else:
            cumulation = []
        sg = cosine_similarity(cumulation, matrix)
        sig = list(enumerate(sg[0]))
        sig = sorted(sig, key=lambda x: x[1], reverse=True)
        sig = sig[:(recommendation_number-1)+len(books_read)]
        final = []
        for i in range(len(sig)):
            isbn = isbns[sig[i][0]]
            if isbn not in books_read:
                final.append(isbn)
        return(final[:recommendation_number])


#This function combines the recommendations to generate the final list
def combined_recommendation(genre_recommendations, description_recommendations, number_of_recommendations, titles, books_read, isbns):
    #Creates a list of unique books
    full_list = []
    selected_list = []
    counter = 0
    #Checks each list and adds to full if ISBN or title is not already added
    #If both lists have it, it is added to selected list
    while counter<min([len(genre_recommendations), len(description_recommendations)]) and len(selected_list)<number_of_recommendations:
        if genre_recommendations[counter] not in full_list:
            full_list.append(genre_recommendations[counter])
        elif titles[isbns.index(genre_recommendations[counter])] not in [titles[isbns.index(book_read)] for book_read in books_read]:
            if titles[isbns.index(genre_recommendations[counter])] not in [titles[isbns.index(selected)] for selected in selected_list]:
                selected_list.append(genre_recommendations[counter])
        if description_recommendations[counter] not in full_list:
            full_list.append(description_recommendations[counter])
        elif titles[isbns.index(description_recommendations[counter])] not in [titles[isbns.index(book_read)] for book_read in books_read]:
            if titles[isbns.index(description_recommendations[counter])] not in [titles[isbns.index(selected)] for selected in selected_list]:
                selected_list.append(description_recommendations[counter])
        counter+=1
    #If the number of recommendations matches it just returns the list
    if len(selected_list) == number_of_recommendations:
        return(selected_list)
    #If the selected values aren't enough it pulls from the full list until full
    else:
        remaining = number_of_recommendations - len(selected_list)
        newcounter = 0
        while newcounter < len(full_list) and remaining != 0:
            if full_list[newcounter] not in selected_list:
                if titles[isbns.index(full_list[newcounter])] not in [titles[isbns.index(book_read)] for book_read in books_read]:
                    if titles[isbns.index(full_list[newcounter])] not in [titles[isbns.index(selected)] for selected in selected_list]:
                        selected_list.append(full_list[newcounter])
                        remaining -= 1
            newcounter += 1
        return(selected_list)
